{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WrongAnswer2 Training Records","text":""},{"location":"#team-members","title":"Team members","text":"<p>Eric, Jun, Kenny</p>"},{"location":"#contests","title":"Contests","text":"<ul> <li> <p>Ieeextreme 18.0 </p> <ul> <li>Rank 475 / 8785 (Score: 1070.39) Top 5.4%</li> </ul> </li> <li> <p>Ieeextreme 17.0 </p> </li> </ul>"},{"location":"#upcoming-contests","title":"Upcoming Contests","text":""},{"location":"#icpc-training","title":"ICPC Training","text":"<ul> <li>01/11/2024</li> <li>12/10/2024</li> <li>05/10/2024</li> </ul>"},{"location":"#codeforce-training","title":"CodeForce Training","text":"<ul> <li>02/11/2024</li> <li>01/11/2024</li> </ul>"},{"location":"codeforce_training/20241101/training/","title":"01/11/2024","text":"<p>Codeforces Round 983 (Div. 2)</p>"},{"location":"codeforce_training/20241102/training/","title":"02/11/2024","text":"<p>Codeforces Round 984 (Div. 3)</p>"},{"location":"codeforce_training/20241116/training/","title":"Codeforces Round 987 (Div. 2)","text":"<p>Contest: Codeforces Round 987 (Div. 2)</p> <p>Author: Eric</p> <p>Solved: 2/6</p> <p>Upsolved: 3/6</p>"},{"location":"codeforce_training/20241116/training/#submissions","title":"Submissions","text":""},{"location":"codeforce_training/20241116/training/#a-penchick-and-modern-monument","title":"A. Penchick and Modern Monument","text":"<p>Solution: Greedy, replace all non most frequent elements.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n\nint main() {\n    int t;\n    cin&gt;&gt;t;\n    while(t--) {\n        int n;\n        cin&gt;&gt;n;\n        vector&lt;int&gt; v(n);\n        for(int i=0; i&lt;n; i++) {\n            cin&gt;&gt;v[i];\n        }\n        map&lt;int,int&gt; mp;\n        for(int i=0; i&lt;n; i++) {\n            mp[v[i]]++;\n        }\n        int ans = INT_MAX;\n        for(auto&amp; p: mp) {\n            ans = min(ans, n-p.second);\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codeforce_training/20241116/training/#b-penchick-and-satay-sticks","title":"B. Penchick and Satay Sticks","text":"<p>Observation 1: You can only sort an array segment when it is in the order of x+1 x x+3 x+2 ...</p> <p>e.g. 2 1 4 3 6 5</p> <p>Observation 2: There will be multiple unsorted segment</p> <p>e.g. 1 2 3 (5 4 7 6) 8 9 (11 10) 12 13</p> <p>Solution: Loop from left to right, check each elemnt is sorted or not, if unsorted, check whether it can be sorted based on observation 1.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n\nint main() {\n    int t;\n    cin&gt;&gt;t;\n    while(t--) {\n        int n;\n        cin&gt;&gt;n;\n        vector&lt;int&gt; v(n);\n        for(int i=0; i&lt;n; i++) {\n            cin&gt;&gt;v[i];\n        }\n        bool ans = true;\n        int l = 0;\n        int r = 0;\n        while(r&lt;n) {\n            while(r&lt;n &amp;&amp; v[r]!=r+1) {\n                r++;\n            }\n            int x = l+1;\n            while(l&lt;r &amp;&amp; l+1&lt;n) {\n                if(v[l]!=x &amp;&amp; v[l]!=x+1) {\n                    ans = false;\n                }\n                if(v[l+1]!=x &amp;&amp; v[l+1]!=x+1) {\n                    ans = false;\n                }\n                x += 2;\n                l += 2;\n            }\n            while(r&lt;n &amp;&amp; v[r]==r+1) {\n                r++;\n            }\n            l = r;\n        }\n        (ans)  ? cout&lt;&lt;\"YES\"&lt;&lt;endl : cout&lt;&lt;\"NO\"&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codeforce_training/20241116/training/#c-penchick-and-bbq-buns","title":"C. Penchick and BBQ Buns","text":"<p>Observation 1: Since 1 is a perfect square, if n is even, we can form a sequence of </p> <p>1 1 2 2 ...</p> <p>Observation 2: If n is odd, we need 1 element that occurs 3 times. Since 3^2+4^2=5^2, we can form a sequence of </p> <p>1 (8 elements) 1 (12 elements) 2 (2 elements) 1 2 (even number of elements)</p> <p>so that it has an odd length of at least 27.</p> <p>We can fill in those even sequences using observation 1, and fill even number of elements at the back.</p> <p>Therefore, there exist solution for any odd n of n&gt;=27.</p> <pre><code>#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n#include &lt;bits/stdc++.h&gt;\n#define ll long long\n#define INF 0x3f3f3f3f\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin&gt;&gt;t;\n    while(t--) {\n        int n;\n        cin&gt;&gt;n;\n        if(n%2==0) {\n            int x = 1;\n            for(int i=0; i&lt;n; i+=2) {\n                cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;x&lt;&lt;\" \";\n                x++;\n            }\n            cout&lt;&lt;endl;\n        } else if(n&gt;=27) {\n            cout&lt;&lt;\"1 3 3 4 4 5 5 6 6 1 7 7 8 8 9 9 10 10 11 11 12 12 2 13 13 1 2 \";\n            int x = 14;\n            for(int i=28; i&lt;=n; i+=2) {\n                cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;x&lt;&lt;\" \";\n                x++;\n            }\n            cout&lt;&lt;endl;\n        } else {\n            cout&lt;&lt;-1&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"icpc_training/20241005/training/","title":"The 2nd Universal Cup. Stage 22: Hangzhou","text":"<p>Virtual Contest: The 2nd Universal Cup. Stage 22: Hangzhou</p> <p>Solutions: https://qoj.ac/download.php?type=attachments&amp;id=1516&amp;r=1</p>"},{"location":"icpc_training/20241005/training/#submissions","title":"Submissions","text":"<p>Problem M. V-Diagram (Submitted by Jun)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\n\nint t, n, center;\nll a[300005];\nll temp, minA;\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    cin &gt;&gt; t;\n    while(t--) {\n        cin &gt;&gt; n;\n        minA = 1000000005;\n        for (int i = 0; i &lt; n; i++) {\n            cin &gt;&gt; temp;\n            a[i] = temp;\n            if (a[i] &lt; minA) {\n                minA = a[i];\n                center = i;\n            }\n        }\n\n        ll leftSum = a[center + 1];\n        ll rightSum = a[center - 1];\n\n        for (int i = center; i &gt;= 0; i--) {\n            leftSum += a[i];\n        }\n\n        for (int i = center; i &lt; n; i++) {\n            rightSum += a[i];\n        }\n\n        double leftAvg =  1.0 * leftSum / (center + 2);\n        double rightAvg = 1.0 * rightSum / (n - center + 1);\n\n        if (leftAvg &gt; rightAvg) {\n            ll tempSum = leftSum;\n            ll cnt = center + 2;\n            double tempAvg = 0;\n\n            for (int i = center + 2; i &lt; n; i++) {\n                tempSum += a[i];\n                cnt++;\n                tempAvg = 1.0 * tempSum / cnt;\n                if (tempAvg &gt; leftAvg) {\n                    leftAvg = tempAvg;\n                }    \n            }\n\n            cout &lt;&lt; fixed;\n            cout.precision(10);\n            cout &lt;&lt; leftAvg &lt;&lt; \"\\n\";\n        } else { \n            ll tempSum = rightSum;\n            ll cnt = n - center + 1;\n            double tempAvg = 0;\n\n            for (int i = center - 2; i &gt;= 0; i--) {\n                tempSum += a[i];\n                cnt++;\n                tempAvg = 1.0 * tempSum / cnt;\n                if (tempAvg &gt; rightAvg) {\n                    rightAvg = tempAvg;\n                }    \n            }\n\n            cout &lt;&lt; fixed;\n            cout.precision(10);\n            cout &lt;&lt; rightAvg &lt;&lt; \"\\n\";\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Problem J. Mysterious Tree (Submitted by )</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\n\nint t, n, res, u, v, x, y;\nbool flag;\nstring q;\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    cin &gt;&gt; t;\n\n    while(t--) {\n        cin &gt;&gt; n;\n        flag = false;\n\n        for (int i = 1; i &lt;= n; i += 2) {\n            if (i == n) {\n                q = \"? \" + to_string(i - 1) + \" \" + to_string(i) + \"\\n\";\n            } else {\n                q = \"? \" + to_string(i) + \" \" + to_string(i + 1) + \"\\n\";\n            }\n            cout &lt;&lt; q;\n            cout.flush();\n\n            cin &gt;&gt; res;\n\n            if (res == 1) {\n                if (i == n) {\n                    u = i - 1;\n                    v = i;\n                } else {\n                    u = i;\n                    v = i + 1;\n                }\n\n                if (i == 1) {\n                    x = n - 1;\n                    y = n;\n                } else {\n                    x = 1;\n                    y = 2;\n                }\n                flag = true;\n                break;\n            }\n        }\n\n        if (!flag) {\n            cout &lt;&lt; \"! 1\" &lt;&lt; \"\\n\";\n            cout.flush();\n        } else {\n            q = \"? \" + to_string(u) + \" \" + to_string(x) + \"\\n\";\n            cout &lt;&lt; q;\n            cout.flush();\n            cin &gt;&gt; res;\n            if (res == 0) {\n                q = \"? \" + to_string(v) + \" \" + to_string(x) + \"\\n\";\n                cout &lt;&lt; q;\n                cout.flush();\n                cin &gt;&gt; res;\n                if (res == 0) {\n                    cout &lt;&lt; \"! 1\" &lt;&lt; \"\\n\";\n                    cout.flush();\n                } else {\n                    q = \"? \" + to_string(v) + \" \" + to_string(y) + \"\\n\";\n                    cout &lt;&lt; q;\n                    cout.flush();\n                    cin &gt;&gt; res;\n\n                    if (res == 1) {\n                        cout &lt;&lt; \"! 2\" &lt;&lt; \"\\n\";\n                        cout.flush();\n                    } else {\n                        cout &lt;&lt; \"! 1\" &lt;&lt; \"\\n\";\n                        cout.flush();\n                    }\n                }\n            } else {\n                q = \"? \" + to_string(u) + \" \" + to_string(y) + \"\\n\";\n                cout &lt;&lt; q;\n                cout.flush();\n                cin &gt;&gt; res;\n                if (res == 0) {\n                    q = \"? \" + to_string(v) + \" \" + to_string(x) + \"\\n\";\n                    cout &lt;&lt; q;\n                    cout.flush();\n                    cin &gt;&gt; res;\n                    if (res == 0) {\n                        cout &lt;&lt; \"! 1\" &lt;&lt; \"\\n\";\n                        cout.flush();\n                    } else {\n                        q = \"? \" + to_string(v) + \" \" + to_string(y) + \"\\n\";\n                        cout &lt;&lt; q;\n                        cout.flush();\n                        cin &gt;&gt; res;\n\n                        if (res == 1) {\n                            cout &lt;&lt; \"! 2\" &lt;&lt; \"\\n\";\n                            cout.flush();\n                        } else {\n                            cout &lt;&lt; \"! 1\" &lt;&lt; \"\\n\";\n                            cout.flush();\n                        }\n                    }\n                } else {\n                    cout &lt;&lt; \"! 2\" &lt;&lt; \"\\n\";\n                    cout.flush();\n                }\n            }\n        }\n    }\n\n    cout.flush();\n    return 0;\n}\n</code></pre>"},{"location":"icpc_training/20241012/training/","title":"The 2024 ICPC Asia East Continent Online Contest (I)","text":"<p>Virtual Contest: The 2024 ICPC Asia East Continent Online Contest (I)</p> <p>Solutions: https://qoj.ac/blog/bulijiojiodibuliduo/blog/994</p>"},{"location":"icpc_training/20241012/training/#submissions","title":"Submissions","text":""},{"location":"icpc_training/20241012/training/#problem-a-world-cup","title":"Problem A. World Cup","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\ninline void work(){\n    //beat 2 -&gt; 16\n    //beat 6 -&gt; 8\n    //beat 13 -&gt; 4\n    //beat 27 -&gt; 2\n    int a;\n    cin &gt;&gt; a;\n    int i = 31;\n    int n;\n    int bt = 0;\n    while(i--) {cin &gt;&gt; n; if(a&gt;n)bt++;}\n    if(bt&gt;=31){cout &lt;&lt; \"1\" &lt;&lt; endl; return;} \n    else if(bt&gt;=27){cout &lt;&lt; \"2\" &lt;&lt; endl; return;} \n    else if(bt&gt;=13){cout &lt;&lt; \"4\" &lt;&lt; endl; return;} \n    else if(bt&gt;= 6){cout &lt;&lt; \"8\" &lt;&lt; endl; return;} \n    else if(bt&gt;= 2){cout &lt;&lt;\"16\" &lt;&lt; endl; return;} \n    else {cout &lt;&lt; \"32\" &lt;&lt; endl; return;}\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--) work();\n    return 0;\n}\n</code></pre>"},{"location":"icpc_training/20241012/training/#problem-m-find-the-easiest-problem","title":"Problem M. Find the Easiest Problem","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\ninline void work(){\n    int n; cin &gt;&gt; n;\n    set&lt;string&gt; names[26];\n    for(int i = 0; i &lt; n; i++){\n        string tname, prob, res;\n        cin &gt;&gt; tname &gt;&gt; prob &gt;&gt; res;\n        if(res!=\"accepted\") continue;\n        names[prob[0]-'A'].insert(tname);\n    }\n    int ans = 0;\n    for(int i = 0; i &lt; 26; i++){if(names[i].size() &gt; names[ans].size()) ans = i;}\n    cout &lt;&lt; (char)('A' + ans) &lt;&lt; endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--) work();\n    return 0;\n}\n</code></pre>"},{"location":"icpc_training/20241012/training/#problem-c-permutation-counting-4","title":"Problem C. Permutation Counting 4","text":"<p>Todo:Understand https://qoj.ac/submission/567854 </p>"},{"location":"icpc_training/20241012/training/#f-make-max","title":"F. Make Max","text":"<p>Todo: Understand https://qoj.ac/submission/565950</p>"},{"location":"icpc_training/20241012/training/#g-the-median-of-the-median-of-the-median","title":"G. The Median of the Median of the Median","text":"<p>Todo: Understand https://qoj.ac/submission/565952</p>"},{"location":"icpc_training/20241101/training/","title":"The 3rd Universal Cup. Stage 14: Harbin","text":"<p>Virtual Contest: The 3rd Universal Cup. Stage 14: Harbin</p> <p>Solutions: https://qoj.ac/download.php?type=attachments&amp;id=1817&amp;r=2</p>"},{"location":"icpc_training/20241101/training/#submissions","title":"Submissions","text":""},{"location":"icpc_training/20241101/training/#problem-m-weird-ceiling","title":"Problem M. Weird Ceiling","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n#define eb emplace_back\ninline void work(){\n    ll b;\n    cin &gt;&gt; b;\n    if(b==2) {cout &lt;&lt; 3 &lt;&lt; endl; return;}\n    if(b==1) {cout &lt;&lt; 1 &lt;&lt; endl; return;}\n    vector&lt;ll&gt; factors;\n    for (ll i = 2; i &lt;= sqrt(b); i++) {\n        if (b % i == 0) {factors.eb(i); if(i!=b/i &amp;&amp; i &gt;= 2){factors.eb(b/i);}}\n    }\n    factors.eb(b);\n    sort(factors.begin(), factors.end());\n    ll total = 0;\n    ll prev = 1;\n    for (ll x : factors) {\n        total += (x - prev) * (b / prev);\n        prev = x;\n    }\n    total += 1;\n    cout &lt;&lt; total &lt;&lt; endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t;\n    cin &gt;&gt; t;\n    while(t--) work();\n}\n</code></pre>"},{"location":"icpc_training/20241101/training/#problem-g-welcome-to-join-the-online-meeting-reference-sgcolin","title":"Problem G. Welcome to Join the Online Meeting! (Reference: SGColin)","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define eb emplace_back\n#define all(s) (s).begin(), (s).end()\n\nvoid inline work(){\n    int n,m,k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    vector&lt;int&gt; busy(n+1);\n    for(int i = 0; i &lt; k; i++){\n        int x;\n        cin &gt;&gt; x;\n        busy[x] = 1;\n    }\n\n    vector&lt;vector&lt;int&gt;&gt;g(n+1);\n\n    for(int i = 0; i &lt; m ; i++){\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        if(busy[u] &amp;&amp; busy[v]) continue;\n        if(busy[u]) g[v].eb(u);\n        else if(busy[v]) g[u].eb(v);\n        else {g[v].eb(u); g[u].eb(v);}\n    }\n\n    int root = -1;\n\n    for(int i = 1; i &lt;= n ; i++) {if(busy[i]) continue; root=i; break;}\n    if(root==-1) {cout &lt;&lt; \"No\" &lt;&lt; endl; return;}\n    vector&lt;bool&gt; vis(n+1);\n    queue&lt;int&gt; que; que.push(root); vis[root] = true;\n    vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; ans;\n    while(!que.empty())  {\n        int u = que.front(); que.pop();\n        vector&lt;int&gt; tmp;\n        for(auto v:g[u]) if(!vis[v]) {tmp.eb(v); vis[v] = true; if(!busy[v]) que.push(v);}\n        sort(all(tmp));\n        if(!tmp.empty()) ans.eb(u, tmp);\n    }\n    for(int i = 1 ; i&lt;=n ; i++) if(!vis[i]) { cout &lt;&lt; \"No\" &lt;&lt; endl; return; }\n    cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n    cout &lt;&lt; ans.size() &lt;&lt; endl;\n    for(auto &amp;[u, s] : ans) {\n        cout &lt;&lt; u &lt;&lt; \" \" &lt;&lt; s.size();\n        for(auto x : s) cout &lt;&lt; \" \" &lt;&lt; x;\n        cout &lt;&lt; endl;\n    }\n    return;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    work();\n}\n</code></pre>"},{"location":"icpc_training/20241101/training/#problem-c-giving-directions-in-harbin","title":"Problem C. Giving Directions in Harbin","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nusing namespace std;\n\nint t{};\nint n{}, x{};\nchar d{};\n\nint getDir(char c) {\n    if (c == 'N') {\n        return 0;\n    } else if (c == 'E') {\n        return 1;\n    } else if (c == 'S') {\n        return 2;        \n    } else {\n        return 3;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    cin &gt;&gt; t;\n    while(t--) {\n        cin &gt;&gt; n;\n        int prevDir, curDir;\n\n        for (int i = 0; i &lt; n; i++) {\n            cin &gt;&gt; d &gt;&gt; x;\n            curDir = getDir(d);\n            if (i == 0) {\n                cout &lt;&lt; (n - 1) * 2 + 1 &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\\n';\n                cout &lt;&lt; 'Z' &lt;&lt; ' ' &lt;&lt; x &lt;&lt; '\\n';\n            } else {\n                if (curDir == (prevDir + 1) % 4) {\n                    cout &lt;&lt; 'R' &lt;&lt; '\\n';\n                    cout &lt;&lt; 'Z' &lt;&lt; ' ' &lt;&lt; x &lt;&lt; '\\n';\n                } else {\n                    cout &lt;&lt; 'L' &lt;&lt; '\\n';\n                    cout &lt;&lt; 'Z' &lt;&lt; ' ' &lt;&lt; x &lt;&lt; '\\n';\n                }\n            }\n            prevDir = curDir;\n        }\n    }\n}\n</code></pre>"},{"location":"icpc_training/20241101/training/#problem-k-farm-management-reference-sgcolin","title":"Problem K: Farm Management (Reference: SGColin)","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\ninline ll rd() {\n    ll x = 0;\n    bool f = false;\n    char c = getchar();\n    while (!isdigit(c) &amp;&amp; c != '-' &amp;&amp; c != EOF) c = getchar();\n    if (c == '-') { f = true; c = getchar(); }\n    for (; isdigit(c); c = getchar()) {\n        x = x * 10 + (c - '0');\n    }\n    return f ? -x : x;\n}\n\n#define eb emplace_back\n#define all(s) (s).begin(), (s).end()\n\nconst int N = 1000007;\n\nstruct segtree {\n    ll cnt[4*N] = {0}, sum[4*N] = {0};\n    void pushup(int rt) {\n        cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];\n        sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];\n    }\n    void upd(int rt, int l, int r, int p, ll num) {\n        if (l == r) {\n            cnt[rt] += num;\n            sum[rt] += num * l;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (p &lt;= mid) \n            upd(rt&lt;&lt;1, l, mid, p, num);\n        else \n            upd(rt&lt;&lt;1|1, mid+1, r, p, num);\n        pushup(rt);\n    }\n    ll ksum(int rt, int l, int r, ll k) {\n        if (l == r) return l * k;\n        int mid = (l + r) / 2;\n        if (cnt[rt&lt;&lt;1|1] &gt;= k) \n            return ksum(rt&lt;&lt;1|1, mid+1, r, k);\n        else \n            return sum[rt&lt;&lt;1|1] + ksum(rt&lt;&lt;1, l, mid, k - cnt[rt&lt;&lt;1|1]);\n    }\n} tr;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    ll m;\n    n = rd();\n    m = rd();\n\n    vector&lt;tuple&lt;ll, ll, ll&gt;&gt; s;\n    s.reserve(n);\n    ll totalL = 0;\n\n    for(int i = 0; i &lt; n; i++){\n        ll w = rd(), l = rd(), r = rd();\n        s.emplace_back(w, l, r);\n        totalL += w * l;\n        m -= l;\n    }\n    sort(all(s), [&amp;](const tuple&lt;ll, ll, ll&gt; &amp;a, const tuple&lt;ll, ll, ll&gt; &amp;b) -&gt; bool {\n        return get&lt;0&gt;(a) &gt; get&lt;0&gt;(b);\n    });\n\n    ll ans = totalL + m * get&lt;0&gt;(s.front());\n\n    for(auto &amp;[w, l, r] : s){\n        ll tmp = m + l;\n        ll tmptot = totalL - w * l;\n        if (tr.cnt[1] &lt; tmp) {\n            tmptot += tr.sum[1] + w * (tmp - tr.cnt[1]);\n        }\n        else {\n            tmptot += tr.ksum(1, 1, N-1, tmp);\n        }\n        ans = max(ans, tmptot);\n        tr.upd(1, 1, N-1, w, r - l);\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n</code></pre>"},{"location":"icpc_training/20241101/training/#problem-b-farm-management-reference-sgcolin-chatgpt","title":"Problem B: Farm Management (Reference: SGColin + ChatGPT)","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\n// Structure to represent a point\nstruct P {\n    ll x, y;\n    P(ll x_=0, ll y_=0) : x(x_), y(y_) {}\n\n    // Operator for sorting\n    bool operator&lt;(const P&amp; other) const {\n        return x &lt; other.x || (x == other.x &amp;&amp; y &lt; other.y);\n    }\n\n    // Subtraction operator\n    P operator - (const P&amp; other) const {\n        return P(x - other.x, y - other.y);\n    }\n};\n\n// Cross product of OA and OB vectors\nll cross(const P&amp; O, const P&amp; A, const P&amp; B) {\n    ll dx1 = A.x - O.x;\n    ll dy1 = A.y - O.y;\n    ll dx2 = B.x - O.x;\n    ll dy2 = B.y - O.y;\n    return dx1 * dy2 - dx2 * dy1;\n}\n\n// Function to compute the convex hull using Andrew's algorithm\nvector&lt;P&gt; convex_hull(vector&lt;P&gt; pts) {\n    int n = pts.size();\n    if(n == 0) return {};\n    sort(pts.begin(), pts.end());\n\n    vector&lt;P&gt; hull;\n    // Lower hull\n    for(int i = 0; i &lt; n; ++i){\n        while(hull.size() &gt;=2 &amp;&amp; cross(hull[hull.size()-2], hull[hull.size()-1], pts[i]) &lt;= 0){\n            hull.pop_back();\n        }\n        hull.emplace_back(pts[i]);\n    }\n    // Upper hull\n    int lower_size = hull.size();\n    for(int i = n-2; i &gt;=0 ; --i){\n        while(hull.size() &gt; lower_size &amp;&amp; cross(hull[hull.size()-2], hull[hull.size()-1], pts[i]) &lt;= 0){\n            hull.pop_back();\n        }\n        hull.emplace_back(pts[i]);\n    }\n    // Remove the last point because it's the same as the first one\n    if(hull.size() &gt;1) hull.pop_back();\n    return hull;\n}\n\n// Function to compute twice the area of a polygon\nll polygon_area_twice(const vector&lt;P&gt;&amp; poly){\n    ll area = 0;\n    int n = poly.size();\n    for(int i=0;i&lt;n;i++){\n        int j = (i+1)%n;\n        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;\n    }\n    return abs(area);\n}\n\ninline void work(){\n    int n;\n    scanf(\"%d\", &amp;n);\n    vector&lt;P&gt; points(n);\n    for(int i=0;i&lt;n;i++) scanf(\"%lld %lld\", &amp;points[i].x, &amp;points[i].y);\n\n    // Compute Convex Hull CH1\n    vector&lt;P&gt; CH1 = convex_hull(points);\n    if((int)CH1.size() == n){\n        // All points are on convex hull, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n\n    // Sort CH1 and points to collect interior points using two pointers\n    vector&lt;P&gt; sorted_CH1 = CH1;\n    sort(sorted_CH1.begin(), sorted_CH1.end());\n    sort(points.begin(), points.end());\n\n    vector&lt;P&gt; interior;\n    int ptr1 = 0, ptr2 = 0;\n    int m = sorted_CH1.size();\n    int total = points.size();\n    while(ptr1 &lt; m &amp;&amp; ptr2 &lt; n){\n        if(points[ptr2].x &lt; sorted_CH1[ptr1].x || \n           (points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y &lt; sorted_CH1[ptr1].y)){\n            interior.emplace_back(points[ptr2++]);\n        }\n        else if(points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y == sorted_CH1[ptr1].y){\n            ++ptr1; ++ptr2;\n        }\n        else{\n            ++ptr1;\n        }\n    }\n    // Add any remaining points\n    while(ptr2 &lt; n){\n        interior.emplace_back(points[ptr2++]);\n    }\n\n    if(interior.empty()){\n        // No interior points, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n\n    // Compute Convex Hull of interior points (CH2)\n    vector&lt;P&gt; CH2 = convex_hull(interior);\n\n    // Compute twice the area of CH1\n    ll CH1_area_twice = polygon_area_twice(CH1);\n\n    // Initialize minimum decrease in area\n    ll min_decrease = LLONG_MAX;\n\n    // Rotating Calipers to find the minimum decrease\n    int m1 = CH1.size();\n    int m2 = CH2.size();\n    if(m2 ==0){\n        // No interior convex hull, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n    int j = 0;\n    for(int i =0; i&lt;m1; ++i){\n        P a = CH1[i];\n        P b = CH1[(i+1)%m1];\n        P ab = b - a;\n\n        // Move pointer j to minimize |ab cross (CH2[j] - a)|\n        while(true){\n            int jp = (j +1) % m2;\n            P current = CH2[j] - a;\n            P next_p = CH2[jp] - a;\n            ll cross1 = abs(ab.x * current.y - ab.y * current.x);\n            ll cross2 = abs(ab.x * next_p.y - ab.y * next_p.x);\n            if(cross2 &lt; cross1){\n                j = jp;\n            }\n            else{\n                break;\n            }\n        }\n        // Update minimum decrease\n        P x = CH2[j] - a;\n        ll cross_val = abs(ab.x * x.y - ab.y * x.x);\n        if(cross_val &lt; min_decrease){\n            min_decrease = cross_val;\n            // Early exit if the minimal possible value is found\n            if(min_decrease ==1) break;\n        }\n    }\n\n    // Now, the maximum area of concave polygon is CH1_area_twice - min_decrease\n    ll result = CH1_area_twice - min_decrease;\n    // Ensure the result is positive\n    if(result &gt;0){\n        printf(\"%lld\\n\", result);\n    }\n    else{\n        printf(\"-1\\n\");\n    }\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &amp;t);\n    while(t--) work();\n    return 0;\n}\n</code></pre>"},{"location":"icpc_training/20241101/training/#problem-b-explanation-chatgpt","title":"Problem B Explanation (ChatGPT):","text":""},{"location":"icpc_training/20241101/training/#1-overview-of-the-problem","title":"1. Overview of the Problem","text":"<p>Given $ n $ distinct points in a 2D plane (with no three points collinear), the task is to select a subset of these points (possibly all) and connect them to form a concave polygon with a positive area. The goal is to determine the maximum possible area of such a polygon. If forming a concave polygon is impossible, the output should be -1.</p>"},{"location":"icpc_training/20241101/training/#2-key-concepts-and-terminology","title":"2. Key Concepts and Terminology","text":"<p>Before diving into the code, it's essential to understand some fundamental concepts:</p> <ul> <li> <p>Convex Polygon: A polygon where any line segment connecting two points inside the polygon lies entirely within the polygon. All internal angles are less than 180\u00b0.</p> </li> <li> <p>Concave Polygon: A simple polygon that is not convex. It has at least one internal angle greater than 180\u00b0, creating a \"dent.\"</p> </li> <li> <p>Convex Hull: The smallest convex polygon that encloses all the given points. It can be visualized as the shape formed by a tight elastic band stretched around the outermost points.</p> </li> <li> <p>Cross Product: A mathematical operation on two vectors in 2D space that provides information about their relative orientation. It helps determine whether a sequence of three points makes a left turn, right turn, or are collinear.</p> </li> <li> <p>Rotating Calipers: An algorithmic technique used to solve various computational geometry problems, especially those involving polygons and their properties.</p> </li> </ul>"},{"location":"icpc_training/20241101/training/#3-detailed-breakdown-of-the-code","title":"3. Detailed Breakdown of the Code","text":""},{"location":"icpc_training/20241101/training/#a-defining-the-p-structure","title":"a. Defining the P Structure","text":"<pre><code>// Structure to represent a point\nstruct P {\n    ll x, y;\n    P(ll x_=0, ll y_=0) : x(x_), y(y_) {}\n\n    // Operator for sorting\n    bool operator&lt;(const P&amp; other) const {\n        return x &lt; other.x || (x == other.x &amp;&amp; y &lt; other.y);\n    }\n\n    // Subtraction operator\n    P operator - (const P&amp; other) const {\n        return P(x - other.x, y - other.y);\n    }\n};\n</code></pre> <ul> <li> <p>struct P: Represents a point in 2D space with coordinates $ x $ and $ y $.</p> </li> <li> <p>Constructors and Operators:</p> </li> <li>P(ll x_=0, ll y_=0): Initializes a point with given $ x $ and $ y $ coordinates. Default values are $ 0 $.</li> <li>operator&lt;: Allows points to be sorted first by $ x $-coordinate and then by $ y $-coordinate. This is crucial for algorithms like convex hull construction.</li> <li>operator-: Defines the subtraction of two points, resulting in a vector. This is used in vector operations like cross products.</li> </ul>"},{"location":"icpc_training/20241101/training/#b-cross-product-function","title":"b. Cross Product Function","text":"<pre><code>// Cross product of OA and OB vectors\nll cross(const P&amp; O, const P&amp; A, const P&amp; B) {\n    ll dx1 = A.x - O.x;\n    ll dy1 = A.y - O.y;\n    ll dx2 = B.x - O.x;\n    ll dy2 = B.y - O.y;\n    return dx1 * dy2 - dx2 * dy1;\n}\n</code></pre> <ul> <li> <p>Purpose: Computes the cross product of vectors OA and OB, where $ O $, $ A $, and $ B $ are points.</p> </li> <li> <p>Formula:   $$   \\text{Cross Product} = (A_x - O_x) \\times (B_y - O_y) - (A_y - O_y) \\times (B_x - O_x)   $$</p> </li> <li> <p>Interpretation:</p> </li> <li>If the result is positive, the sequence $ O \\rightarrow A \\rightarrow B $ makes a left turn (counter-clockwise).</li> <li>If it's negative, it's a right turn (clockwise).</li> <li> <p>If the result is zero, the points are collinear.</p> </li> <li> <p>Application: Used in constructing the convex hull and determining the orientation of three points.</p> </li> </ul>"},{"location":"icpc_training/20241101/training/#c-convex-hull-function","title":"c. Convex Hull Function","text":"<pre><code>// Function to compute the convex hull using Andrew's algorithm\nvector&lt;P&gt; convex_hull(vector&lt;P&gt; pts) {\n    int n = pts.size();\n    if(n == 0) return {};\n    sort(pts.begin(), pts.end());\n\n    vector&lt;P&gt; hull;\n    // Lower hull\n    for(int i = 0; i &lt; n; ++i){\n        while(hull.size() &gt;=2 &amp;&amp; cross(hull[hull.size()-2], hull[hull.size()-1], pts[i]) &lt;= 0){\n            hull.pop_back();\n        }\n        hull.emplace_back(pts[i]);\n    }\n    // Upper hull\n    int lower_size = hull.size();\n    for(int i = n-2; i &gt;=0 ; --i){\n        while(hull.size() &gt; lower_size &amp;&amp; cross(hull[hull.size()-2], hull[hull.size()-1], pts[i]) &lt;= 0){\n            hull.pop_back();\n        }\n        hull.emplace_back(pts[i]);\n    }\n    // Remove the last point because it's the same as the first one\n    if(hull.size() &gt;1) hull.pop_back();\n    return hull;\n}\n</code></pre> <ul> <li> <p>Purpose: Computes the convex hull of a given set of points using Andrew's Monotone Chain Algorithm, which is an efficient $ O(n \\log n) $ method.</p> </li> <li> <p>Steps:</p> </li> <li> <p>Sorting:</p> <ul> <li>The points are first sorted based on their $ x $-coordinates. If two points have the same $ x $-coordinate, they're sorted by their $ y $-coordinates.</li> </ul> </li> <li> <p>Building the Lower Hull:</p> <ul> <li>Iteratively adds points to the hull vector.</li> <li>Ensures that the sequence of points in the hull makes a left turn (counter-clockwise). If a right turn or collinear points are detected, the last point is removed from the hull.</li> </ul> </li> <li> <p>Building the Upper Hull:</p> <ul> <li>Similar to the lower hull but iterates from the end towards the beginning.</li> <li>This ensures that the upper boundary of the convex hull is constructed.</li> </ul> </li> <li> <p>Finalizing the Hull:</p> <ul> <li>The last point is removed to prevent duplication since the first and last points are the same after constructing both lower and upper hulls.</li> </ul> </li> <li> <p>Output: A vector of points representing the convex hull in counter-clockwise order.</p> </li> </ul>"},{"location":"icpc_training/20241101/training/#d-polygon-area-calculation-function","title":"d. Polygon Area Calculation Function","text":"<pre><code>// Function to compute twice the area of a polygon\nll polygon_area_twice(const vector&lt;P&gt;&amp; poly){\n    ll area = 0;\n    int n = poly.size();\n    for(int i=0;i&lt;n;i++){\n        int j = (i+1)%n;\n        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;\n    }\n    return abs(area);\n}\n</code></pre> <ul> <li> <p>Purpose: Calculates twice the area of a polygon given its vertices using the Shoelace Formula.</p> </li> <li> <p>Shoelace Formula:   $$   \\text{Area} = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i \\times y_{i+1} - x_{i+1} \\times y_i) \\right|   $$   Since the problem requires twice the area, the function directly computes the sum without dividing by 2.</p> </li> <li> <p>Loop Explanation:</p> </li> <li>Iterates through each vertex $ i $ and its subsequent vertex $ j = (i+1) \\% n $, ensuring a wrap-around for the last vertex back to the first.</li> <li> <p>Aggregates the cross products $ (x_i \\times y_j - x_j \\times y_i) $ to compute the signed area.</p> </li> <li> <p>Output: The absolute value of the accumulated sum, representing twice the positive area of the polygon.</p> </li> </ul>"},{"location":"icpc_training/20241101/training/#e-processing-each-test-case-work-function","title":"e. Processing Each Test Case (work Function)","text":"<pre><code>inline void work(){\n    int n;\n    scanf(\"%d\", &amp;n);\n    vector&lt;P&gt; points(n);\n    for(int i=0;i&lt;n;i++) scanf(\"%lld %lld\", &amp;points[i].x, &amp;points[i].y);\n\n    // Compute Convex Hull CH1\n    vector&lt;P&gt; CH1 = convex_hull(points);\n    if((int)CH1.size() == n){\n        // All points are on convex hull, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n\n    // Sort CH1 and points to collect interior points using two pointers\n    vector&lt;P&gt; sorted_CH1 = CH1;\n    sort(sorted_CH1.begin(), sorted_CH1.end());\n    sort(points.begin(), points.end());\n\n    vector&lt;P&gt; interior;\n    int ptr1 = 0, ptr2 = 0;\n    int m = sorted_CH1.size();\n    int total = points.size();\n    while(ptr1 &lt; m &amp;&amp; ptr2 &lt; n){\n        if(points[ptr2].x &lt; sorted_CH1[ptr1].x || \n           (points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y &lt; sorted_CH1[ptr1].y)){\n            interior.emplace_back(points[ptr2++]);\n        }\n        else if(points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y == sorted_CH1[ptr1].y){\n            ++ptr1; ++ptr2;\n        }\n        else{\n            ++ptr1;\n        }\n    }\n    // Add any remaining points\n    while(ptr2 &lt; n){\n        interior.emplace_back(points[ptr2++]);\n    }\n\n    if(interior.empty()){\n        // No interior points, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n\n    // Compute Convex Hull of interior points (CH2)\n    vector&lt;P&gt; CH2 = convex_hull(interior);\n\n    // Compute twice the area of CH1\n    ll CH1_area_twice = polygon_area_twice(CH1);\n\n    // Initialize minimum decrease in area\n    ll min_decrease = LLONG_MAX;\n\n    // Rotating Calipers to find the minimum decrease\n    int m1 = CH1.size();\n    int m2 = CH2.size();\n    if(m2 ==0){\n        // No interior convex hull, cannot form concave polygon\n        printf(\"-1\\n\");\n        return;\n    }\n    int j = 0;\n    for(int i =0; i&lt;m1; ++i){\n        P a = CH1[i];\n        P b = CH1[(i+1)%m1];\n        P ab = b - a;\n\n        // Move pointer j to minimize |ab cross (CH2[j] - a)|\n        while(true){\n            int jp = (j +1) % m2;\n            P current = CH2[j] - a;\n            P next_p = CH2[jp] - a;\n            ll cross1 = abs(ab.x * current.y - ab.y * current.x);\n            ll cross2 = abs(ab.x * next_p.y - ab.y * next_p.x);\n            if(cross2 &lt; cross1){\n                j = jp;\n            }\n            else{\n                break;\n            }\n        }\n        // Update minimum decrease\n        P x = CH2[j] - a;\n        ll cross_val = abs(ab.x * x.y - ab.y * x.x);\n        if(cross_val &lt; min_decrease){\n            min_decrease = cross_val;\n            // Early exit if the minimal possible value is found\n            if(min_decrease ==1) break;\n        }\n    }\n\n    // Now, the maximum area of concave polygon is CH1_area_twice - min_decrease\n    ll result = CH1_area_twice - min_decrease;\n    // Ensure the result is positive\n    if(result &gt;0){\n        printf(\"%lld\\n\", result);\n    }\n    else{\n        printf(\"-1\\n\");\n    }\n}\n</code></pre> <p>Let's break down each part of the work function:</p>"},{"location":"icpc_training/20241101/training/#i-input-handling","title":"i. Input Handling","text":"<pre><code>int n;\nscanf(\"%d\", &amp;n);\nvector&lt;P&gt; points(n);\nfor(int i=0;i&lt;n;i++) scanf(\"%lld %lld\", &amp;points[i].x, &amp;points[i].y);\n</code></pre> <ul> <li>Read Input:</li> <li>n: Number of points.</li> <li>points: A vector of $ n $ points, each with $ x $ and $ y $ coordinates.</li> </ul>"},{"location":"icpc_training/20241101/training/#ii-computing-the-initial-convex-hull-ch1","title":"ii. Computing the Initial Convex Hull (CH1)","text":"<pre><code>// Compute Convex Hull CH1\nvector&lt;P&gt; CH1 = convex_hull(points);\nif((int)CH1.size() == n){\n    // All points are on convex hull, cannot form concave polygon\n    printf(\"-1\\n\");\n    return;\n}\n</code></pre> <ul> <li>Compute Convex Hull (CH1):</li> <li>Uses the previously defined convex_hull function.</li> <li> <p>CH1 represents the outer boundary (convex hull) of all points.</p> </li> <li> <p>Check for Convexity:</p> </li> <li>If all points lie on the convex hull (CH1.size() == n), it implies that there are no interior points.</li> <li>Without interior points, it's impossible to form a concave polygon (since removing any point would maintain convexity or reduce the number of vertices below 3).</li> <li>Action: Print -1 and terminate the current test case.</li> </ul>"},{"location":"icpc_training/20241101/training/#iii-identifying-interior-points","title":"iii. Identifying Interior Points","text":"<pre><code>// Sort CH1 and points to collect interior points using two pointers\nvector&lt;P&gt; sorted_CH1 = CH1;\nsort(sorted_CH1.begin(), sorted_CH1.end());\nsort(points.begin(), points.end());\n\nvector&lt;P&gt; interior;\nint ptr1 = 0, ptr2 = 0;\nint m = sorted_CH1.size();\nint total = points.size();\nwhile(ptr1 &lt; m &amp;&amp; ptr2 &lt; n){\n    if(points[ptr2].x &lt; sorted_CH1[ptr1].x || \n       (points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y &lt; sorted_CH1[ptr1].y)){\n        interior.emplace_back(points[ptr2++]);\n    }\n    else if(points[ptr2].x == sorted_CH1[ptr1].x &amp;&amp; points[ptr2].y == sorted_CH1[ptr1].y){\n        ++ptr1; ++ptr2;\n    }\n    else{\n        ++ptr1;\n    }\n}\n// Add any remaining points\nwhile(ptr2 &lt; n){\n    interior.emplace_back(points[ptr2++]);\n}\n\nif(interior.empty()){\n    // No interior points, cannot form concave polygon\n    printf(\"-1\\n\");\n    return;\n}\n</code></pre> <ul> <li> <p>Objective: Extract points not on the convex hull (CH1). These are the interior points and are crucial for forming a concave polygon.</p> </li> <li> <p>Steps:</p> </li> <li> <p>Sorting for Efficient Comparison:</p> <ul> <li>sorted_CH1: A copy of CH1, sorted using the overloaded &lt; operator. This ensures both CH1 and points are sorted to facilitate a two-pointer approach.</li> <li>points: All points are also sorted.</li> </ul> </li> <li> <p>Two-Pointer Technique:</p> <ul> <li>Pointers:</li> <li>ptr1: Iterates through sorted_CH1.</li> <li>ptr2: Iterates through sorted points.</li> <li>Comparison Logic:</li> <li>If the current point in points is not on CH1 (i.e., its $ x $-coordinate is less or, if equal, its $ y $-coordinate is less than the current CH1 point), it's an interior point and is added to the interior vector.</li> <li>If the current point in points matches the current CH1 point (x and y both), it's part of CH1, so both pointers are incremented without adding to interior.</li> <li>Else, the CH1 pointer (ptr1) is advanced.</li> </ul> </li> <li> <p>Adding Remaining Points:</p> <ul> <li>After the main loop, any remaining points in points that haven't been compared are considered interior points and are added to interior.</li> </ul> </li> <li> <p>Final Check:</p> <ul> <li>If no interior points are found (interior.empty()), it's impossible to form a concave polygon, so the code prints -1 and ends the test case.</li> </ul> </li> </ul>"},{"location":"icpc_training/20241101/training/#iv-computing-the-convex-hull-of-interior-points-ch2","title":"iv. Computing the Convex Hull of Interior Points (CH2)","text":"<pre><code>// Compute Convex Hull of interior points (CH2)\nvector&lt;P&gt; CH2 = convex_hull(interior);\n</code></pre> <ul> <li> <p>Purpose: To construct the convex hull of the interior points. This helps in effectively determining how to form a concave polygon by \"cutting\" into the initial convex hull (CH1).</p> </li> <li> <p>Reasoning:</p> </li> <li>The second convex hull (CH2) represents the boundary of the inner set of points.</li> <li>The relationship between CH1 and CH2 provides insights into how to adjust the polygon to make it concave while maximizing the area.</li> </ul>"},{"location":"icpc_training/20241101/training/#v-calculating-the-area-of-the-initial-convex-hull","title":"v. Calculating the Area of the Initial Convex Hull","text":"<pre><code>// Compute twice the area of CH1\nll CH1_area_twice = polygon_area_twice(CH1);\n</code></pre> <ul> <li> <p>Purpose: Calculates twice the area of the initial convex hull (CH1) using the polygon_area_twice function.</p> </li> <li> <p>Reasoning:</p> </li> <li>Since the problem requires outputting twice the area, this value serves as a starting point to determine the area reduction needed to make the polygon concave.</li> </ul>"},{"location":"icpc_training/20241101/training/#vi-initializing-the-minimum-decrease-in-area","title":"vi. Initializing the Minimum Decrease in Area","text":"<pre><code>// Initialize minimum decrease in area\nll min_decrease = LLONG_MAX;\n</code></pre> <ul> <li> <p>Purpose: Sets a variable min_decrease to the maximum possible value, which will later be updated to store the minimum possible decrease in area when transforming the convex hull into a concave polygon.</p> </li> <li> <p>Reasoning:</p> </li> <li>The goal is to find the smallest possible reduction in area that still allows the polygon to become concave.</li> <li>This ensures that the resulting concave polygon has the maximum possible area.</li> </ul>"},{"location":"icpc_training/20241101/training/#vii-rotating-calipers-technique-to-find-minimal-decrease","title":"vii. Rotating Calipers Technique to Find Minimal Decrease","text":"<pre><code>// Rotating Calipers to find the minimum decrease\nint m1 = CH1.size();\nint m2 = CH2.size();\nif(m2 ==0){\n    // No interior convex hull, cannot form concave polygon\n    printf(\"-1\\n\");\n    return;\n}\nint j = 0;\nfor(int i =0; i&lt;m1; ++i){\n    P a = CH1[i];\n    P b = CH1[(i+1)%m1];\n    P ab = b - a;\n\n    // Move pointer j to minimize |ab cross (CH2[j] - a)|\n    while(true){\n        int jp = (j +1) % m2;\n        P current = CH2[j] - a;\n        P next_p = CH2[jp] - a;\n        ll cross1 = abs(ab.x * current.y - ab.y * current.x);\n        ll cross2 = abs(ab.x * next_p.y - ab.y * next_p.x);\n        if(cross2 &lt; cross1){\n            j = jp;\n        }\n        else{\n            break;\n        }\n    }\n    // Update minimum decrease\n    P x = CH2[j] - a;\n    ll cross_val = abs(ab.x * x.y - ab.y * x.x);\n    if(cross_val &lt; min_decrease){\n        min_decrease = cross_val;\n        // Early exit if the minimal possible value is found\n        if(min_decrease ==1) break;\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: Determines the minimum decrease in area required to turn the convex hull CH1 into a concave polygon by leveraging the Rotating Calipers technique.</p> </li> <li> <p>Key Variables:</p> </li> <li>m1: Number of points in CH1.</li> <li>m2: Number of points in CH2.</li> <li> <p>j: Pointer/index used for iterating through CH2 in conjunction with each edge of CH1.</p> </li> <li> <p>Steps:</p> </li> <li> <p>Handle Edge Cases:</p> <ul> <li>If CH2 is empty (m2 == 0), it means there are no interior convex hull points, making it impossible to form a concave polygon. The code outputs -1 and terminates.</li> </ul> </li> <li> <p>Iterating Over Each Edge of CH1:</p> <ul> <li>For each edge $ ab $ in CH1 (from point a to point b):</li> <li>P ab = b - a;: Computes the vector representation of edge $ ab $.</li> </ul> </li> <li> <p>Finding the Point in CH2 Minimizing the Cross Product with Edge $ ab $:</p> <ul> <li>The goal is to find a point $ x $ in CH2 such that the absolute value of the cross product $ |ab \\times (x - a)| $ is minimized.</li> <li>A smaller cross product implies a smaller area reduction when introducing a concave vertex at $ x $, thereby maximizing the remaining area.</li> </ul> </li> <li> <p>Rotating Calipers Mechanism:</p> <ul> <li>While Loop:</li> <li>Continuously evaluates whether moving the pointer j to the next point in CH2 decreases the cross product.</li> <li>jp = (j + 1) % m2;: Computes the next index in CH2, ensuring wrap-around using modulo operation.</li> <li>current and next_p: Vectors from point a to the current and next points in CH2, respectively.</li> <li>cross1 and cross2: Compute the absolute cross products with the current and next points.</li> <li>Decision:<ul> <li>If moving to next_p results in a smaller cross product (cross2 &lt; cross1), update j to jp.</li> <li>Otherwise, stop moving j for the current edge.</li> </ul> </li> </ul> </li> <li> <p>Updating the Minimum Decrease:</p> <ul> <li>After finding the optimal point $ x $ in CH2 for the current edge $ ab $, compute the cross product $ |ab \\times (x - a)| $.</li> <li>If this value is smaller than the current min_decrease, update min_decrease.</li> <li>Early Termination:</li> <li>If min_decrease reaches 1 (the smallest possible positive integer, given that all points are distinct and no three are collinear), break out of the loop early as no smaller value is possible.</li> </ul> </li> </ul>"},{"location":"icpc_training/20241101/training/#viii-final-computation-and-output","title":"viii. Final Computation and Output","text":"<pre><code>// Now, the maximum area of concave polygon is CH1_area_twice - min_decrease\nll result = CH1_area_twice - min_decrease;\n// Ensure the result is positive\nif(result &gt;0){\n    printf(\"%lld\\n\", result);\n}\nelse{\n    printf(\"-1\\n\");\n}\n</code></pre> <ul> <li>Calculating the Result:</li> <li> <p>result = CH1_area_twice - min_decrease;</p> <ul> <li>CH1_area_twice: Twice the area of the initial convex hull.</li> <li>min_decrease: The minimal area reduction needed to convert the convex hull into a concave polygon.</li> <li>Interpretation: Subtracting min_decrease from CH1_area_twice yields the maximum possible area of a concave polygon that can be formed.</li> </ul> </li> <li> <p>Final Check and Output:</p> </li> <li>If the result is positive, it signifies that a valid concave polygon exists, and its twice area is printed.</li> <li>If result is not positive, it's impossible to form a concave polygon with positive area under the given constraints, so -1 is printed.</li> </ul>"},{"location":"icpc_training/20241101/training/#4-example","title":"4.  Example","text":""},{"location":"icpc_training/20241101/training/#example-input","title":"Example Input","text":"<pre><code>1\n5\n0 0\n2 0\n1 1\n2 2\n0 2\n</code></pre> <ul> <li>Interpretation:</li> <li>1 Test Case:<ul> <li>5 Points:</li> <li>$ (0, 0) $</li> <li>$ (2, 0) $</li> <li>$ (1, 1) $</li> <li>$ (2, 2) $</li> <li>$ (0, 2) $</li> </ul> </li> </ul>"},{"location":"icpc_training/20241101/training/#step-by-step-execution","title":"Step-by-Step Execution","text":"<ol> <li>Compute Convex Hull (CH1):</li> <li>For the given points, the convex hull would include all points except $ (1, 1) $, as it's an interior point.</li> <li> <p>CH1: $ [(0, 0), (2, 0), (2, 2), (0, 2)] $</p> </li> <li> <p>Check Convexity:</p> </li> <li> <p>CH1.size() = 4, n = 5**: Not all points are on the convex hull. Proceed.</p> </li> <li> <p>Identify Interior Points:</p> </li> <li> <p>Interior Points: $ [(1, 1)] $</p> </li> <li> <p>Compute Convex Hull of Interior Points (CH2):</p> </li> <li>Since there's only one interior point, the convex hull is the point itself.</li> <li> <p>CH2: $ [(1, 1)] $</p> </li> <li> <p>Calculate Twice the Area of CH1:</p> </li> <li>Formula:      $$      \\text{Area} = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i \\times y_{i+1} - x_{i+1} \\times y_i) \\right|      $$</li> <li> <p>Calculation:</p> <ul> <li>$ (0 \\times 0 - 2 \\times 0) = 0 $</li> <li>$ (2 \\times 2 - 2 \\times 0) = 4 $</li> <li>$ (2 \\times 2 - 0 \\times 2) = 4 $</li> <li>$ (0 \\times 0 - 0 \\times 2) = 0 $</li> <li>Sum: $ 0 + 4 + 4 + 0 = 8 $</li> <li>Twice the Area: $ |8| = 8 $</li> </ul> </li> <li> <p>Initialize min_decrease:</p> </li> <li> <p>min_decrease: Initially set to $ LLONG_MAX $</p> </li> <li> <p>Applying Rotating Calipers:</p> </li> <li> <p>Iterate Over Each Edge of CH1:</p> <p>First Edge: $ (0, 0) \\rightarrow (2, 0) $  - Vector $ ab $: $ (2-0, 0-0) = (2, 0) $  - Special Point from CH2: $ (1,1) - (0,0) = (1,1) $  - Cross Product: $ |2 \\times 1 - 0 \\times 1| = |2| = 2 $  - Update min_decrease: $ \\min(\\text{LLONG_MAX}, 2) = 2 $</p> <p>Second Edge: $ (2, 0) \\rightarrow (2, 2) $  - Vector $ ab $: $ (2-2, 2-0) = (0, 2) $  - Special Point from CH2: $ (1,1) - (2,0) = (-1,1) $  - Cross Product: $ |0 \\times 1 - 2 \\times (-1)| = |2| = 2 $  - Update min_decrease: $ \\min(2, 2) = 2 $</p> <p>Third Edge: $ (2, 2) \\rightarrow (0, 2) $  - Vector $ ab $: $ (0-2, 2-2) = (-2, 0) $  - Special Point from CH2: $ (1,1) - (2,2) = (-1,-1) $  - Cross Product: $ |-2 \\times (-1) - 0 \\times (-1)| = |2| = 2 $  - Update min_decrease: $ \\min(2, 2) = 2 $</p> <p>Fourth Edge: $ (0, 2) \\rightarrow (0, 0) $  - Vector $ ab $: $ (0-0, 0-2) = (0, -2) $  - Special Point from CH2: $ (1,1) - (0,2) = (1,-1) $  - Cross Product: $ |0 \\times (-1) - (-2) \\times 1| = |2| = 2 $  - Update min_decrease: $ \\min(2, 2) = 2 $</p> </li> <li> <p>Final min_decrease: $ 2 $</p> </li> <li> <p>Compute the Result:</p> </li> <li> <p>Formula:      [      \\text{Result} = \\text{CH1_area_twice} - \\text{min_decrease} = 8 - 2 = 6      ]</p> </li> <li>Check:<ul> <li>Since $ 6 &gt; 0 $, a valid concave polygon exists.</li> </ul> </li> <li>Output: 6</li> </ol>"},{"location":"icpc_training/20241101/training/#final-output-for-the-example","title":"Final Output for the Example","text":"<p>6</p> <p>Interpretation: Twice the maximum area of the concave polygon that can be formed with the given points is 6, which corresponds to an area of 3.</p>"},{"location":"icpc_training/20241101/training/#5-summary-of-the-algorithms-workflow","title":"5. Summary of the Algorithm's Workflow","text":"<ol> <li>Input Parsing:</li> <li> <p>Read all points for each test case.</p> </li> <li> <p>Initial Convex Hull (CH1) Construction:</p> </li> <li>Determine the convex hull of all points.</li> <li> <p>If all points lie on CH1, it's impossible to form a concave polygon; output -1.</p> </li> <li> <p>Identifying Interior Points:</p> </li> <li> <p>Extract points that are not on CH1. These are potential candidates to introduce concavity into the polygon.</p> </li> <li> <p>Secondary Convex Hull (CH2) Construction:</p> </li> <li>Compute the convex hull of the interior points.</li> <li> <p>If there are no interior points (CH2 is empty), output -1.</p> </li> <li> <p>Area Computation:</p> </li> <li> <p>Calculate twice the area of the initial convex hull (CH1).</p> </li> <li> <p>Minimal Area Decrease Determination:</p> </li> <li>For each edge in CH1, find the point in CH2 that, when used to introduce a concave vertex, results in the smallest possible area reduction.</li> <li> <p>Use the Rotating Calipers technique to efficiently iterate and find this minimal decrease.</p> </li> <li> <p>Final Area Calculation:</p> </li> <li>Subtract the minimal decrease from the area of CH1 to obtain the maximum possible area of a concave polygon.</li> <li> <p>Ensure the result is positive before outputting; otherwise, output -1.</p> </li> <li> <p>Output the Result:</p> </li> <li>For each test case, output the computed value or -1 as per the conditions.</li> </ol>"},{"location":"icpc_training/20241101/training/#6-key-optimizations-implemented-in-the-code","title":"6. Key Optimizations Implemented in the Code","text":"<p>To ensure that the code runs efficiently within the given constraints (especially with large inputs), several optimizations are employed:</p> <ol> <li>Efficient Convex Hull Construction:</li> <li> <p>Andrew's Monotone Chain Algorithm is used, which runs in $ O(n \\log n) $ time and is suitable for large datasets.</p> </li> <li> <p>Two-Pointer Technique for Identifying Interior Points:</p> </li> <li> <p>By sorting both CH1 and points, the two-pointer approach reduces the time complexity of identifying interior points from $ O(n \\log n) $ (using binary search) to $ O(n) $, which is crucial when $ n $ is large.</p> </li> <li> <p>Rotating Calipers for Minimal Decrease Calculation:</p> </li> <li> <p>Instead of naively iterating over all possible point-edge pairs (which would be computationally expensive), the Rotating Calipers technique efficiently traverses points and edges to find the optimal minimal decrease in area.</p> </li> <li> <p>Early Termination:</p> </li> <li> <p>If the minimum possible decrease (min_decrease) reaches 1, the algorithm terminates early since this is the smallest possible positive integer value, ensuring no further unnecessary computations.</p> </li> <li> <p>Fast Input/Output Operations:</p> </li> <li> <p>The use of scanf and printf (as opposed to cin and cout) significantly speeds up input and output operations, which is beneficial when dealing with a large number of test cases and points.</p> </li> <li> <p>Avoiding Redundant Calculations:</p> </li> <li>By pre-sorting and efficiently managing pointers, the code avoids recalculating or re-evaluating points and edges, ensuring optimal runtime performance.</li> </ol>"}]}